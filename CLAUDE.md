# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

`nln` is a performance-optimized command-line utility written in Rust that removes trailing newlines and carriage returns from stdin. The tool preserves newlines within content, only removing trailing ones. It's designed to be extremely fast and handles mixed line endings (LF, CRLF, CR).

### Design Principles

**Priority: Minimal complexity and zero dependencies**
- Keep the codebase as simple as possible
- Avoid adding external dependencies to the core functionality
- Only use standard library features
- Prefer straightforward algorithms over clever but complex solutions

## Key Architecture

### Core Algorithm (src/lib.rs)

The main logic is in the `snickerdoodle` function which uses a buffered streaming approach:
- Reads input in chunks using `BufRead::fill_buf()`
- Maintains a newline buffer (`nlbuf`) to track potential trailing newlines
- Only outputs newlines when followed by actual content
- Performs single-pass processing without backtracking

The algorithm is optimized for performance with:
- Minimal allocations (reuses newline buffer)
- Efficient byte-level operations
- No regex or string parsing overhead

### Library vs Binary

- `src/lib.rs`: Contains the `snickerdoodle` function, exposed as a library specifically for fuzzing with cargo-fuzz
- `src/main.rs`: CLI wrapper that handles argument parsing and stdin/stdout streaming
- Note: The library is NOT intended for external consumption, only for internal fuzzing

### Performance Annotations

The codebase uses `#[cold]` annotations on infrequently-called functions (help, version, error messages) to optimize the hot path.

## Development Commands

The project uses `mise` as the task runner. All commands are in `mise.toml`:

### Building and Testing
- `mise run build` - Build optimized release binary
- `mise run test` - Run tests with cargo-nextest
- `mise run ci` - Run all CI checks (format check, clippy, test, build)

### Code Quality
- `mise run fmt` - Format code with rustfmt
- `mise run fmt:check` - Check formatting without modifying files
- `mise run clippy` - Run clippy lints (fails on warnings)

### Fuzzing
- `mise run fuzz` - Run fuzzer with cargo-fuzz (requires nightly Rust)
- `mise run fuzz-cmin` - Compact the fuzzing corpus

### Other
- `mise run testdata` - Generate benchmark test data files
- `mise run install` - Install the binary locally

### Single Test Execution
To run a specific test:
```bash
cargo test test_name
# or with nextest
cargo nextest run test_name
```

## Code Formatting

The project uses Rust edition 2024 formatting style with strict settings in `rustfmt.toml`:
- Imports grouped by Std/External/Crate with one item per import
- Unix line endings required
- Comments wrapped and code in doc comments formatted

## Release Profile

The release build uses aggressive optimization settings in `Cargo.toml`:
- `strip = true` - Remove debug symbols
- `lto = "fat"` - Full link-time optimization
- `codegen-units = 1` - Maximum optimization at cost of compile time

## Testing Strategy

Tests in `src/lib.rs` cover:
- Edge cases: empty input, only newlines, large inputs
- Line ending variants: LF, CRLF, CR, mixed
- Position variants: leading, trailing, middle newlines
- The fuzzer validates the invariant: output never ends with `\r` or `\n`

## Benchmark Data

The `benchmarks/` directory contains test files for performance testing (generated by `examples/testdata.rs`):
- Various sizes: small, medium, large, huge
- Various patterns: no trailing, many trailing, trailing then content
- Special cases: empty, only newlines, mixed line endings
